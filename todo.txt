reference_constant から派生したオブジェクトに対して, 以下のように, まとめて
特定のメンバ函数を呼び出すコードが成立していない.

	const vector<reference_constant*>& all = reference_constant::m_all;
	for_each(all.begin(), all.end(), mem_fun(&reference_constant::output));

しょうがないので現状個別にメンバ函数を呼び出している.
---------------------------------------------------------------------
例えば Linkages_of_identifiers/1_ok など

--ms 指定時の static 函数を正しくコンパイルできていない. Microsoft Assembler
の仕様理解に問題あり.
-------------------------------------------------------------------
3_Real_floating_and_integer/1_ok/test00{0,1,2}.c

--ms --x86 指定時, 実行時に Floating point inexact result 例外が発生して
いる.
-------------------------------------------------------------------
3_Expressions/16_Assignment_operators/1_ok/test003.c

--ms --x86 指定時, 実行時に Floating point inexact result 例外が発生して
いる. 函数 test0211 で 2 つ目の printf を呼び出す前のスタックは期待通りで

|     |
+-----+ <---- esp
|  <-------"%d, %f\n" のアドレス
+-----+
|  <------ x の値 0xc8 = 200
+-----+
|     |
|  <------ y の値 8.0
+-----+
|     |

のようになっていることを確認した.
---------------------------------------------------------------------
3_Expressions/16_Assignment_operators/1_ok/test000.c

実行時に Floating point inexact result 例外が発生していることのみ確認した.
---------------------------------------------------------------------
4_Character_constants/1_ok/test00{0,5}.c

--ms --x86 cygwin 版, VS 版.
(但し 2018.08.21 の試験では VS Release 版で test000.c のみ再現)
Segmentation fault により実行時エラーになるが, VS から実行すると再現しない.
chkstc が呼ばれるべきなのに、呼ばれてないとか(?)
---------------------------------------------------------------------
13_Nonlocal_jumps/test00{0,1,2}.c

--ms 指定時. setjmp の呼び出しは第 2 引数に以下のように rbp - (stack サイズ)を指
定する必要がある. 以下はスタックサイズ 0x20 の例

        rcx に第一引数をセットした状態

	mov         rdx,rbp
	add         rdx,0FFFFFFFFFFFFFFE0h
	call        _setjmp

これを指定しないと, nt.dll 内で不正メモリアクセスが発生する. さらに
函数の入り口でスタックを 0xcc で埋めるコードも必要になる. これをしないと
0xC0000028 例外が発生する. この対応はターゲットコードの Debug ビルドのみ
有効で Release ビルドではまた別の対応が必要になる. また --x86 に
対しても似たような対応が必要になる.
---------------------------------------------------------------------
