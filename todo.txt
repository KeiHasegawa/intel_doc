--ms モード C++
例外処理は未実装. 今後もおそらく実装できないと思われる.
VC++ の cl.exe のオプションに /FAs のようにコンパイル結果を出力することが
できるが, 残念ながらこの出力結果がそのままアセンブルすることができない.
これができなければば解析もできない.

rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown  ; . で構文エラー
rtc$TMZ	ENDS

hoge PROC
...
	lea	rcx, OFFSET FLAT:__C32237B3_Source@cpp  ; FLAT: で構文エラー

構文エラーの原因となる . を _ に書き換えて
OFFSET FLAT: を OFFSET のように機械的に書き換えてみたが, アセンブルは
正常終了するが, プログラムの動作が期待通りではない.
--------------------------------------------------------------------
--ms モード C++
函数の外側の変数の初期化と終了ができていない. text$di, text$yd が期待通り
動作していない.

ファイルスコープで
int a = 123;
int b = a;

のようなコードがあった場合

CRT$XCU SEGMENT
?b$initializer@@xxxx DD initialize_for_b
CRT$XCU ENDS

text$di SEGMENT
initialize_for_b PROC
    push ebp
    sub esp, 32
    ....
    ....
    pop ebp
    ret
text$di ENDS

のようにしてみたが動作しない. initialize_for_b が呼び出されることはない.


x86 ビルドで最小と思われるプログラムを作ってみた

	.model	flat

PUBLIC	_mainCRTstartup
_TEXT	SEGMENT
_mainCRTStartup	PROC
	call	func
	mov	eax, 123
	ret
_mainCRTStartup ENDP
_TEXT	ENDS
_CRT SEGMENT READONLY DWORD ALIAS ( ".CRT$XCU" )
	DWORD func
_CRT	ENDS
_TEXT	SEGMENT
func	PROC
	ret
func	ENDP
_TEXT	ENDS
	END

まぁ、うまくいっていない. func が _mainCRTStartup の前に呼ばれることはない.
. から始まるセクション(セグメント)を宣言するにはこうするとよいらしいことは分かった.

2020.09.12 16:03
d:/tmp/Project6
% cat aaa.cpp
int a = 123;

int b = a;

int main()
{
	return 0;
}
% cat bbb.asm
_CRT	SEGMENT ALIAS (".CRT$XCU")
	DD	12H
_CRT	ENDS
	END

これで aaa.obj と bbb.obj をリンクして実行すると、期待通り 0x12 番地に
函数コールしようとしてエラーになっている.

x86 のみ解決!!!
2020.09.12 16:25
d:/tmp/Project7
% cat aaa.cpp
int main()
{
	return 0;
}
% cat bbb.asm
	.model	flat

_TEXT	SEGMENT
func	PROC
	ret
func	ENDP
_TEXT	ENDS

_CRT	SEGMENT ALIAS (".CRT$XCU")
	DD	func
_CRT	ENDS
	END

これで main 函数の前に func が呼ばれることを確認した. x86 のみ.

x64 は d:/tmp/Project9 で解決. x86 と少し異なる.
% cat aaa.cpp
int main()
{
	return 0;
}
% cat bbb.asm
_TEXT	SEGMENT
func	PROC
	ret
func	ENDP
_TEXT	ENDS
_CRT	SEGMENT READONLY ALIGN(8) ALIAS (".CRT$XCU")
	DQ	func
_CRT	ENDS
	END
--------------------------------------------------------------------
--ms モード C++
new, delete の呼び出しコードを生成するとリンクエラーを引き起こしてしまうため
回避策として代わりに malloc, free を呼び出している

=>
2020.09.13 10:30 謎 d:/tmp/Project10 で試したところできている.
--------------------------------------------------------------------
--ms モード
main 函数を正しくコンパイルできていない. しょうがないのでテストでは main
函数からテストプログラムの main 函数を呼び出すといったことをしている.

main 函数で hello world を印字するプログラムのリンクで

1>a.obj : error LNK2019: 未解決の外部シンボル __acrt_iob_func が関数 printf で参照されました
1>a.obj : error LNK2019: 未解決の外部シンボル __local_stdio_printf_options が関数 printf で参照されました
1>a.obj : error LNK2019: 未解決の外部シンボル __stdio_common_vfprintf が関数 printf で参照されました

というエラーが出てしまう.

cl.exe で通常通り hello world を印字するプログラムをコンパイルすると

      __acrt_iob_func  ではなく
      
__imp___acrt_iob_func  らしい

      __stdio_common_vfprintf ではなく

__imp___stdio_common_vfprintf  らしい

しかし __local_stdio_printf_options に関しては外部参照ではなくコンパイルした
ファイルの中に定義が存在している.

__acrt_iob_func は

d:/Windows Kits/10/Include/10.0.17763.0/ucrt/corecrt_wstdio.h

にその宣言があり

_ACRTIMP_ALT FILE* __cdecl __acrt_iob_func(unsigned _Ix);

のように書かれているがプリプロセスの結果は

FILE*   __acrt_iob_func(unsigned _Ix);

である. 同様に

__stdio_common_vfprintf も

d:/Windows Kits/10/Include/10.0.17763.0/ucrt/stdio.h

にその宣言があり

_ACRTIMP int __cdecl __stdio_common_vfprintf(

のように書かれている.

__local_stdio_printf_options に関しては

D:/Windows Kits/10/Include/10.0.17763.0/ucrt/corecrt_stdio_config.h

にその inline 定義があるが vs_header_conv.pl でこれを書き換えている.
---------------------------------------------------------------------
reference_constant から派生したオブジェクトに対して, 以下のように, まとめて
特定のメンバ函数を呼び出すコードが成立していない.

	const vector<reference_constant*>& all = reference_constant::m_all;
	for_each(all.begin(), all.end(), mem_fun(&reference_constant::output));

しょうがないので現状個別にメンバ函数を呼び出している.
---------------------------------------------------------------------
例えば Linkages_of_identifiers/1_ok など

--ms 指定時の static 函数を正しくコンパイルできていない. Microsoft Assembler
の仕様理解に問題あり.
-------------------------------------------------------------------
3_Real_floating_and_integer/1_ok/test00{0,1,2}.c

--ms --x86 指定時, 実行時に Floating point inexact result 例外が発生して
いる.
-------------------------------------------------------------------
3_Expressions/16_Assignment_operators/1_ok/test003.c

--ms --x86 指定時, 実行時に Floating point inexact result 例外が発生して
いる. 函数 test0211 で 2 つ目の printf を呼び出す前のスタックは期待通りで

|     |
+-----+ <---- esp
|  <-------"%d, %f\n" のアドレス
+-----+
|  <------ x の値 0xc8 = 200
+-----+
|     |
|  <------ y の値 8.0
+-----+
|     |

のようになっていることを確認した.
---------------------------------------------------------------------
3_Expressions/16_Assignment_operators/1_ok/test000.c

実行時に Floating point inexact result 例外が発生していることのみ確認した.
---------------------------------------------------------------------
4_Character_constants/1_ok/test00{0,5}.c

--ms --x86 cygwin 版, VS 版.
(但し 2018.08.21 の試験では VS Release 版で test000.c のみ再現)
Segmentation fault により実行時エラーになるが, VS から実行すると再現しない.
chkstc が呼ばれるべきなのに、呼ばれてないとか(?)
---------------------------------------------------------------------
13_Nonlocal_jumps/test00{0,1,2}.c

--ms 指定時. setjmp の呼び出しは第 2 引数に以下のように rbp - (stack サイズ)を指
定する必要がある. 以下はスタックサイズ 0x20 の例

        rcx に第一引数をセットした状態

	mov         rdx,rbp
	add         rdx,0FFFFFFFFFFFFFFE0h
	call        _setjmp

これを指定しないと, nt.dll 内で不正メモリアクセスが発生する. さらに
函数の入り口でスタックを 0xcc で埋めるコードも必要になる. これをしないと
0xC0000028 例外が発生する. この対応はターゲットコードの Debug ビルドのみ
有効で Release ビルドではまた別の対応が必要になる. また --x86 に
対しても似たような対応が必要になる.
---------------------------------------------------------------------
